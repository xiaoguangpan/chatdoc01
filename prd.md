# **产品需求文档 (PRD): 本地智能文档问答助手 (MVP)**

**版本:** Final 1.1
**日期:** 2025-04-24
**作者:** [您的名字 或 AI助手]

## 1. 引言

### 1.1 项目目标
开发一个本地部署的智能文档问答助手，旨在帮助内部员工快速分析和解读公司内部的技术协议 Word 文档（特别是包含核心表格的加密文档），通过自然语言问答的方式提取关键信息，并支持文档版本管理。

### 1.2 MVP 目标
实现核心的单文档、特定版本问答功能：用户能够关联项目、上传本地加密 Word 文档（支持版本管理），系统在本地解析文档（文本与表格），进行向量化处理，并通过外部 LLM API 对选定文档版本的内容进行问答，提供基础的文档内容预览和精确到多个来源的定位高亮。

### 1.3 核心功能范围 (MVP 包含)
*   本地运行（打包为可执行文件，启动本地 Web 服务）。
*   基于项目号管理文档，支持文档版本控制（上传新版本、查看历史版本、软删除）。
*   支持上传本地 Word 文档 (.docx)，通过本机 COM 组件处理加密文档。
*   本地解析 Word 文档，提取文本和表格内容。
*   使用元数据富化策略关联段落和表格的逻辑关系。
*   本地进行文本切分和向量化。
*   本地存储向量数据 (ChromaDB) 和元数据 (SQLite)，数据持久化。
*   调用外部 LLM API (火山方舟 Doubao) 进行问答。
*   提供 Web UI (通过浏览器访问 `localhost`):
    *   项目选择/创建。
    *   文档上传及版本管理界面。
    *   基础文档内容预览（按原文顺序拼接 HTML 片段）。
    *   聊天式问答界面。
    *   答案附带所有来源引用，每个引用均可点击。
    *   点击引用可定位并高亮预览区对应的一个或多个内容块。
    *   处理耗时操作时提供进度反馈（加载动画/进度条）。
*   持久化存储项目、文档基础信息、文档版本、聊天记录和配置。
*   基本的可配置项（API Key, RAG 参数）。

### 1.4 非 MVP 范围 (后续考虑)
*   **跨文档/跨项目查询:** 本 MVP 严格限制在**单个当前活动文档的特定版本**的问答范围内。跨文档/项目问答需在未来独立模块实现，以防结果混淆。
*   **文档版本差异对比:** 对比不同版本文档内容差异并高亮显示的功能。
*   **高级文档渲染:** 不追求与 Word 完全一致的视觉效果。
*   **图片内容理解与问答:** 虽然选型 LLM 支持，但 MVP 阶段不处理图片。
*   **用户登录与权限管理。**
*   **复杂的错误处理与日志系统。**
*   **支持 Word 以外的格式 (Excel, PDF 等)。**
*   **实时协作功能。**
*   **数据库与文件存储的集中化部署（公司内部服务器）。**

### 1.5 目标用户
公司内部需要处理和分析技术协议文档，并关注文档版本变化的员工（如技术、项目、商务人员）。

## 2. 系统架构

### 2.1 概述
采用**混合架构**: 一个在用户本地运行的后端 Web 服务器 (FastAPI) + 一个通过本地浏览器访问的前端用户界面。整体打包成一个可执行文件 (`.exe`) 方便分发和启动。此架构解决了调用本地 COM 组件处理加密 Word 文档的需求，同时利用 Web 技术栈提供现代化的用户界面。

### 2.2 主要组件
*   **后端 (Local FastAPI Server):**
    *   处理 HTTP 请求。
    *   通过 `pywin32` 调用本地 COM 接口与 Microsoft Word 交互，读取文档内容。
    *   使用 `LlamaIndex` 进行文档加载、解析、切分 (Node Parsing)、向量化 (Embedding) 和检索 (Retrieval)。
    *   与本地 `ChromaDB` 交互进行向量存储和查询。
    *   与本地 `SQLite` 数据库交互进行元数据、项目、文档基础信息、文档版本、聊天记录和配置的持久化存储。
    *   调用外部 LLM API (火山方舟) 获取问答结果。
    *   提供 API 接口供前端调用。
    *   托管静态前端文件 (HTML, CSS, JS)。
*   **前端 (Browser UI @ `localhost`):**
    *   使用 HTML, Tailwind CSS, Vanilla JavaScript 构建。
    *   提供用户界面，用于项目管理、文档上传与版本控制、内容预览、问答交互。
    *   调用后端 API 获取数据和执行操作。
    *   实现预览区内容的动态渲染和高亮定位。
    *   显示处理进度。
*   **向量数据库 (Local ChromaDB):**
    *   在本地磁盘持久化存储文档块 (Chunks) 的向量和元数据。
    *   用于高效的相似性检索。
*   **关系型数据库 (Local SQLite):**
    *   在本地磁盘持久化存储结构化数据 (项目、文档基础信息、文档版本、聊天记录、配置等)。
*   **COM 接口 (`pywin32`):**
    *   用于在后端安全地与本地安装的 Microsoft Word 交互，读取加密文档内容。

### 2.3 数据流 (问答示例)
1.  **用户选择项目、文档及特定版本 (前端)。**
2.  **用户在该版本对话界面输入问题 (前端)。**
3.  **前端发送请求（包含问题及当前活动 `version_id`）到本地 FastAPI 后端。**
4.  **后端使用 LlamaIndex:**
    *   将问题向量化 (使用本地嵌入模型)。
    *   在 ChromaDB 中查询与**当前活动 `version_id`** 相关的相似 Chunks (通过元数据过滤)。
5.  **后端构建 Prompt:** 包含用户问题和检索到的 Chunks 文本及元数据。
6.  **后端调用外部 LLM API (火山方舟)，发送 Prompt。**
7.  **LLM API 返回答案。**
8.  **后端处理答案，提取所有来源 Chunk 的 `html_id`。**
9.  **后端将答案和来源信息存入 SQLite (聊天记录，关联 `session_id`，`session_id` 关联 `version_id`)，并返回给前端。**
10. **前端显示答案，并提供包含所有来源的可点击引用列表。**
11. **用户点击任一来源引用 (前端)。**
12. **前端根据来源 Chunk 的 `html_id`，在预览区滚动到对应位置并高亮显示该 HTML 元素。**

## 3. 技术栈

*   **编程语言:** Python 3.9+
*   **后端框架:** FastAPI
*   **RAG 框架:** LlamaIndex
*   **COM 交互:** pywin32 (Windows only dependency)
*   **嵌入模型:** Sentence Transformers 库 (`bge-base-zh-v1.5`)
*   **向量数据库:** ChromaDB (Python client)
*   **关系型数据库:** SQLite (Python `sqlite3` module)
*   **LLM API Client:** requests 或 火山方舟 Python SDK
*   **前端:** HTML5, Tailwind CSS, Vanilla JavaScript
*   **打包工具:** PyInstaller (或其他类似工具)
*   **Word 文档处理依赖:** 本地安装 Microsoft Word

## 4. 功能需求 (MVP)

### 4.1 项目管理
*   **FR-PM-001:** 应用启动时，或在上传文件前，应提供项目选择/创建区域。用户必须先选择或创建项目才能进行后续操作。
*   **FR-PM-002:** 显示现有项目列表，默认按创建时间降序排列。
*   **FR-PM-003:** 提供项目列表筛选功能（按项目号或名称模糊搜索），方便快速定位。
*   **FR-PM-004:** 提供“新建项目”功能。用户输入新的项目号后，需校验其唯一性，然后创建。
*   **FR-PM-005:** 用户界面应清晰展示当前选定的项目。

### 4.2 文档上传、版本管理与处理
*   **FR-DU-001:** 用户在选定项目后，提供文件上传入口，仅接受 `.docx` 文件。
*   **FR-DU-002:** 后端接收到文件后：
    *   **版本检测:** 根据文件名（去除可能的版本标识）检查所选项目中是否已存在对应的基础文档记录 (`Documents` 表)。如果存在，则视为上传该文档的**新版本**；如果不存在，则视为**新文档**，需先创建基础文档记录。
    *   **文件存储:** 将文件保存到本地指定存储位置（路径可配置），建议存储的文件名包含版本信息（如 `基础文档ID_v版本号_时间戳.docx`）以避免冲突。
*   **FR-DU-003:** 调用 COM 接口打开 Word 文档，**必须健壮地处理 COM 可能出现的各种异常** (如 Word 未安装、文件损坏、密码保护无法打开、权限不足等)，并向用户提供明确的错误提示。
*   **FR-DU-004:** 逐一提取文档中的段落 (Paragraphs) 和表格 (Tables) 内容。
    *   **提取表格:**
        *   **主要策略:** 尝试将表格内容转换为 **Markdown** 格式。此格式能较好地保留表格结构，便于 LLM 理解。
        *   **注意与权衡:** 需明确告知用户，Markdown 转换可能无法 100% 保留 Word 中极其复杂的表格样式（如复杂合并单元格、特殊背景色、字体效果等）。转换的重点在于准确提取**表格内的文本内容和基本的行列结构**。若 Markdown 转换导致内容严重失真或混乱，应记录错误并考虑在未来版本中引入更专业的表格处理库或备选策略。
        *   **备选策略:** (非 MVP) 若 Markdown 普遍效果不佳，可考虑将表格内容序列化为更简单的文本格式（如 CSV 格式，或单元格内容用特殊符号分隔），但这会丢失更多结构信息。
    *   **关联性处理 (策略二: 元数据富化):**
        *   **描述:** 此策略通过为独立提取的段落和表格 Chunk 添加详细的上下文元数据来维护它们之间的逻辑关联。
        *   **实现:** 在解析文档时，识别并记录 Chunk 间的邻近关系。例如，为一个表格 Chunk 的元数据添加 `preceded_by_paragraph_id: [ID]` 或 `followed_by_paragraph_id: [ID]` 来标识紧邻的段落。同时，为可能引出表格的段落（如包含“见下表”等关键词）或表格后的解释性段落，在其元数据中记录关联表格的 ID (`related_table_id: [ID]`)。这些元数据将在 RAG 检索后提供给 LLM，帮助其理解上下文。
*   **FR-DU-005:** 使用 LlamaIndex 的 `NodeParser` (配置 `RecursiveCharacterTextSplitter` 或类似策略) 进行文本切分 (Chunking)。切分参数（如 `chunk_size`, `chunk_overlap`）需可配置，并提供合理的默认值。每个 Chunk 必须包含详细的元数据（关联的**文档版本 ID** `version_id`、基础文档 ID `doc_base_id`、项目 ID `project_id`、在文档中的大致顺序 `sequence_in_doc`、块类型 `block_type` ['paragraph'/'table']、关联信息 `relation_info`、以及一个用于前端定位的唯一 HTML 元素 ID `html_id`）。
*   **FR-DU-006:** 使用本地 `bge-base-zh-v1.5` 嵌入模型对每个 Chunk 进行向量化 (Embedding)。
*   **FR-DU-007:** 将 Chunk 文本、向量和元数据存入 ChromaDB 的 `document_chunks` Collection 中。
*   **FR-DU-008:** 在 SQLite 中记录文档基础信息 (`Documents` 表) 和版本信息 (`DocumentVersions` 表)。如果是新文档，先创建 `Documents` 记录，再创建 `DocumentVersions` 记录 (版本号为 1，`is_latest=TRUE`)；如果是新版本，则创建新的 `DocumentVersions` 记录（版本号递增，`is_latest=TRUE`），并将该文档之前所有版本的 `is_latest` 标志更新为 `FALSE`。
*   **FR-DU-009:** 文档处理（解析、切分、向量化、存储）完成后，更新 SQLite 中对应版本的 `status` 为 'ready'，并通知前端刷新界面，使用户可以访问新版本。若处理失败，则更新 `status` 为 'error' 并记录 `error_message`。
*   **FR-DU-010:** **极其重要:** 必须确保通过 COM 打开的 Word 文档实例和 Word 应用进程 (`doc.Close()`, `word_app.Quit()`) 在每次操作完成后都被**完全、正确地关闭和释放**，以避免内存泄露、进程残留或影响用户正常使用 Word。建议使用 `try...finally` 结构确保释放操作总能执行。
*   **FR-DU-011:** **进度反馈:** 由于文档处理可能耗时较长（特别是首次处理大文档），**必须**在处理过程中向用户提供清晰的视觉反馈。
    *   **实现:** 在前端触发处理后，立即显示明确的“正在处理文档 [文件名] v[版本号]…”状态信息，并配合一个**持续的加载动画**（例如，使用 Tailwind CSS 的 `animate-spin` 或类似效果的 SVG/GIF）。如果技术上可行且能较准确地估算（例如，基于已处理的页数或 COM 对象的进度），可以考虑实现一个简单的**百分比进度条**，但这会增加复杂度，加载动画是最低要求。

### 4.3 文档版本查看与管理 (UI)
*   **FR-DV-001:** 在项目管理区（区域 A），当用户展开一个项目时，应清晰地显示该项目下的**基础文档列表**（按 `original_filename` 分组或排序）。
*   **FR-DV-002:** 用户点击基础文档名称，应能展开显示其**所有非软删除版本的列表**。版本列表应显示关键信息，如版本号 (`version_number`)、上传时间 (`upload_time`)，并按版本号或时间降序排列（最新版本在最前）。
*   **FR-DV-003:** 用户可以点击选择列表中的**任意版本**进行查看。点击后，该版本被设为“当前活动版本”，系统应立即加载该版本的内容到预览区（区域 B）和对应的聊天记录到问答区（区域 C）。UI 上应有明确指示当前活动的是哪个文档的哪个版本。
*   **FR-DV-004:** 默认情况下，当用户首次选择一个基础文档时，系统应自动加载其**最新的、未被软删除**的版本。
*   **FR-DV-005:** 为每个非最新版本提供“**软删除**”操作入口（例如，版本条目旁边的一个“垃圾桶”图标）。
    *   **交互:** 点击删除图标 -> 弹出确认对话框 -> 用户确认。
    *   **后端逻辑:** 在 SQLite 的 `DocumentVersions` 表中，将对应 `version_id` 的 `is_deleted` 标志设为 `TRUE`。**注意：不物理删除文件或 ChromaDB 中的向量数据。**
    *   **UI 表现:** 被软删除的版本默认在版本列表中**隐藏**。可以提供一个选项（如复选框“显示已删除版本”）来查看这些被删除的版本（以置灰等方式区分）。
    *   **查询影响:** 被软删除的版本（`is_deleted=TRUE`）的 Chunks **绝对不能**参与任何问答检索过程。

### 4.4 文档预览
*   **FR-PV-001:** 当用户选择一个文档的**特定版本**时，预览区域（区域 B）应加载并显示该版本对应的原始内容。
*   **FR-PV-002:** 后端需提供一个 API endpoint，接收 `version_id` 作为参数，返回该版本所有 Chunks 按照 `sequence_in_doc` 排序的 HTML 片段列表。每个片段必须包含其唯一的 `html_id`（与存储在 ChromaDB 元数据中的 ID 一致）。
    *   段落 -> `<p id="unique_html_id_for_chunk_1">...</p>`
    *   Markdown 转换后的表格 -> `<div id="unique_html_id_for_chunk_2">...rendered markdown table...</div>` (用 `div` 包裹并赋予 ID)
*   **FR-PV-003:** 前端获取到 HTML 片段列表后，按顺序将其动态插入到预览区域的容器中进行渲染。
*   **FR-PV-004:** 预览区域必须支持垂直滚动条，以便用户浏览长文档。

### 4.5 问答交互
*   **FR-QA-001:** 问答交互区（区域 C）提供聊天记录显示区域，清晰展示对话历史（用户问题和系统回答）。应支持滚动查看历史消息。
*   **FR-QA-002:** 提供一个文本输入框（建议支持多行输入以便提问复杂问题）和一个“发送”按钮，供用户提交问题。
*   **FR-QA-003:** 用户提交问题后，前端将问题文本和**当前活动文档的 `version_id`** 发送给后端 API。后端执行 RAG 流程：
    *   **检索阶段:** 使用 LlamaIndex 查询引擎，在 ChromaDB 中检索与问题语义相关且**元数据中 `version_id` 匹配当前活动版本 ID** 的 Chunks。
    *   **生成阶段:** 构建包含用户问题和检索到的相关 Chunks 内容（可能还有其元数据提示）的 Prompt，调用火山方舟 LLM API。
    *   **重要限制:** 必须通过严格的过滤机制（在 LlamaIndex 查询时或之后）确保 RAG 流程**仅**使用当前选定文档版本的数据，绝不能混入其他版本或其他文档的数据。
*   **FR-QA-004:** 系统回答应在聊天记录区清晰展示。**关键要求：** 回答内容之后，**必须**附带一个列表，列出**所有**对生成该答案有贡献的来源 Chunks 的引用。
    *   **展现形式:** 例如: "根据文档，服务器要求至少需要 16GB 内存 [来源 1, 来源 5, 来源 8]"。或者将来源列表单独展示在答案下方。
    *   **引用内容:** 每个引用应提供一个易于理解的标识符（例如，简单的数字 "[1]", "[2]"），并可能在鼠标悬停时显示该 Chunk 的简短预览或元数据。
*   **FR-QA-005:** 来源列表中的**每一个**引用标识符（如 "[1]", "[2]"）都**必须**是可点击的链接或按钮。
*   **FR-QA-006:** 用户的提问和系统生成的回答（包括其引用的**所有**来源 Chunks 的 `html_id` 列表）都应持久化存储到 SQLite 的 `Messages` 表中，并关联到正确的 `session_id`（该 session 关联到特定的 `version_id`）。

### 4.6 来源高亮与导航
*   **FR-HL-001:** 当用户点击聊天记录中答案附带的**任何一个**来源引用标识符时。
*   **FR-HL-002:** 前端 JavaScript 捕获点击事件，并获取该引用关联的 Chunk 的 `html_id`。
*   **FR-HL-003:** 使文档预览区域（区域 B）自动平滑滚动，将具有对应 `html_id` 的 HTML 元素滚动到可视区域内（最好是视图中部或顶部）。
*   **FR-HL-004:** 对该 HTML 元素应用一个视觉上明显区别于普通文本的**高亮样式**（例如，醒目的背景色、边框）。如果一个答案引用了多个来源，点击不同引用应能分别定位并高亮对应的元素。
*   **FR-HL-005:** 高亮效果应该是暂时的。当用户进行下一次问答、点击另一个答案的引用、或者切换文档/版本时，之前的高亮效果应自动清除。

### 4.7 配置管理
*   **FR-CFG-001:** 系统需要存储和使用火山方舟 LLM 的 API Key。
    *   **存储:** 使用 SQLite 的 `Settings` 表存储。Key 的值建议进行简单的 Base64 编码后存储，以避免明文暴露。
    *   **配置方式:** 提供一个默认的 API Key 值（可以是空字符串或占位符）。在 UI 中提供一个入口（例如，设置菜单或主界面某个角落的按钮），允许用户输入或修改 API Key 并保存到数据库。后端 API 应能读取此配置。
*   **FR-CFG-002:** 其他可能影响 RAG 效果的参数（如 `chunk_size`, `chunk_overlap`, 使用的嵌入模型名称 `embedding_model`）应在后端代码或配置文件中有明确的默认值。MVP 阶段可以不提供 UI 修改入口，但代码结构上应易于未来扩展为可配置。

### 4.8 持久化
*   **FR-PER-001:** 所有结构化数据，包括项目信息、文档基础信息、文档版本记录、聊天会话、聊天消息、用户配置等，都**必须**使用本地 SQLite 数据库 (`database.db`) 进行持久化存储。数据库文件应存储在用户本地的一个稳定位置（例如，应用程序数据目录）。
*   **FR-PER-002:** ChromaDB 向量存储也**必须**配置为在本地磁盘进行持久化，确保存储的向量和元数据在应用程序重启后依然可用。ChromaDB 的持久化路径也应存储在本地稳定位置。

## 5. 数据模型 / 数据库 Schema

### 5.1 SQLite Schema (`database.db`)

*   **Projects Table:**
    *   `project_id` (TEXT, PRIMARY KEY) - 项目号，用户输入，唯一
    *   `project_name` (TEXT, NULLABLE) - 项目名称（可选）
    *   `creation_time` (TIMESTAMP, DEFAULT CURRENT_TIMESTAMP)
*   **Documents Table:** *(存储文档的基础信息，与文件名对应)*
    *   `doc_base_id` (INTEGER, PRIMARY KEY AUTOINCREMENT)
    *   `project_id` (TEXT, NOT NULL, FOREIGN KEY references Projects(project_id))
    *   `original_filename` (TEXT, NOT NULL) - 用户上传时的原始文件名 (不含路径，用于标识同一文档的不同版本)
    *   `creation_time` (TIMESTAMP, DEFAULT CURRENT_TIMESTAMP)
*   **DocumentVersions Table:** *(存储每个版本的信息)*
    *   `version_id` (INTEGER, PRIMARY KEY AUTOINCREMENT)
    *   `doc_base_id` (INTEGER, NOT NULL, FOREIGN KEY references Documents(doc_base_id))
    *   `version_number` (INTEGER, NOT NULL) - 由系统生成的版本序号 (例如，同一 `doc_base_id` 下从 1 开始递增)
    *   `stored_filename` (TEXT, NOT NULL) - 在服务器上存储的文件名 (包含版本或时间戳信息，确保唯一性)
    *   `stored_filepath` (TEXT, NOT NULL) - 文件在本地存储的完整路径
    *   `upload_time` (TIMESTAMP, DEFAULT CURRENT_TIMESTAMP)
    *   `status` (TEXT, NOT NULL, CHECK(status IN ('processing', 'ready', 'error')), DEFAULT 'processing') - 文档处理状态
    *   `error_message` (TEXT, NULLABLE) - 如果处理出错，记录错误信息
    *   `is_latest` (BOOLEAN, NOT NULL, DEFAULT TRUE) - 标记是否为该基础文档的最新（非删除）版本
    *   `is_deleted` (BOOLEAN, NOT NULL, DEFAULT FALSE) - 软删除标记
*   **ChatSessions Table:** *(每次打开一个文档版本进行问答可视为一个会话)*
    *   `session_id` (INTEGER, PRIMARY KEY AUTOINCREMENT)
    *   `version_id` (INTEGER, NOT NULL, FOREIGN KEY references DocumentVersions(version_id)) - **核心关联：会话属于哪个文档的哪个版本**
    *   `start_time` (TIMESTAMP, DEFAULT CURRENT_TIMESTAMP)
    *   `last_update_time` (TIMESTAMP, DEFAULT CURRENT_TIMESTAMP) - 可用于排序或清理旧会话
*   **Messages Table:** *(存储用户问题和系统回答)*
    *   `message_id` (INTEGER, PRIMARY KEY AUTOINCREMENT)
    *   `session_id` (INTEGER, NOT NULL, FOREIGN KEY references ChatSessions(session_id))
    *   `sender` (TEXT, NOT NULL, CHECK(sender IN ('user', 'system'))) - 消息发送者
    *   `text` (TEXT, NOT NULL) - 问题或答案的文本内容
    *   `retrieved_chunk_html_ids` (TEXT, NULLABLE) - 存储系统回答所引用的所有来源 Chunk 的 `html_id` 列表，建议使用 JSON 格式的字符串存储 (e.g., `'["id1", "id5", "id8"]'`)，仅对 `sender='system'` 的消息有效。
    *   `timestamp` (TIMESTAMP, DEFAULT CURRENT_TIMESTAMP)
*   **Settings Table:** *(存储可配置项)*
    *   `key` (TEXT, PRIMARY KEY) - 配置项名称 (e.g., 'llm_api_key', 'embedding_model', 'chunk_size', 'chunk_overlap')
    *   `value` (TEXT) - 配置项的值 (API Key 建议 Base64 编码)

### 5.2 ChromaDB Schema (Vector Store)

*   **Collection Name:** `document_chunks` (硬编码或未来可配置)
*   **Stored Item (Chunk) Structure:**
    *   **Embedding Vector:** (由 `bge-base-zh-v1.5` 生成的向量)
    *   **Document Text:** (Chunk 的原始文本内容)
    *   **Metadata Dictionary:**
        *   `version_id` (Integer): **必须包含，用于过滤检索，关联到 SQLite `DocumentVersions` 表的 `version_id`**
        *   `doc_base_id` (Integer): 基础文档 ID，冗余存储方便管理
        *   `project_id` (String): 所属项目 ID，冗余存储方便管理
        *   `html_id` (String): 用于前端定位和高亮的唯一 HTML 元素 ID
        *   `block_type` (String): 'paragraph' 或 'table'
        *   `sequence_in_doc` (Integer): Chunk 在原文档中的大致顺序
        *   `relation_info` (String, Nullable): 记录与相邻块关联信息的文本描述 (e.g., "follows_paragraph_id:123", "precedes_table_id:45")
        *   *(LlamaIndex 可能会自动添加其他元数据，如文件名、块哈希等，这些可以保留)*

## 6. 用户界面 (UI) & 用户体验 (UX)

### 6.1 页面布局 (文字描述)
采用响应式设计理念，但在 MVP 阶段优先保证在标准桌面浏览器窗口（例如，1920x1080 或类似分辨率）下的清晰、高效布局。建议使用**三栏式布局**：

*   **区域 A: 项目/文档/版本管理树 (左侧固定宽度侧边栏 - 例如 20%-25% 宽度)**
    *   **顶部:** "新建项目" 按钮和项目列表的筛选/搜索输入框。
    *   **主体:** 一个可滚动的树状视图或可折叠列表：
        *   **第一层 (项目):** 显示项目号 (`project_id`)。点击项目名称可展开/折叠其下的文档。项目按创建时间降序排列。
        *   **第二层 (基础文档):** 在展开的项目下，显示该项目包含的基础文档列表（使用 `original_filename`）。点击基础文档名称可展开/折叠其下的版本。
        *   **第三层 (文档版本):** 在展开的基础文档下，显示其所有非软删除的版本列表。每行显示版本号 (`version_number`)、上传时间 (`upload_time`)，并可能显示状态图标（如“处理中”、“就绪”、“错误”）。最新版本应有明确标识（如“(最新)”）。每个非最新版本旁边应有一个“软删除”图标。
    *   **交互:** 点击某个具体的版本号，将其设为**当前活动版本**。此操作会触发区域 B（预览区）和区域 C（问答区）加载该版本对应的内容和聊天记录。当前活动版本应在树状视图中有明显选中状态。
    *   **操作按钮:** 在选定项目或文档后，应出现上下文相关的操作按钮，如 "上传新文档到此项目" 或 "上传新版本到此文档"。
    *   **底部/其他位置:** 全局“设置”入口，用于配置 API Key 等。

*   **区域 B: 文档预览区 (中间主区域 - 例如 50%-55% 宽度，宽度可调)**
    *   **顶部:** 清晰显示当前预览的是哪个项目下的哪个文档的哪个版本（例如，“项目 5501 / 技术协议.docx / v2”）。
    *   **主体:** 显示当前活动版本的基础 HTML 渲染内容。内容应从上到下按原始文档顺序排列。必须支持流畅的垂直滚动。背景和字体应保证良好的可读性。
    *   **高亮效果:** 当用户点击问答区的来源引用时，此区域对应的 HTML 元素应能被准确定位并应用高亮样式。

*   **区域 C: 问答交互区 (右侧固定宽度侧边栏 - 例如 20%-25% 宽度)**
    *   **顶部:** 也可再次强调当前对话关联的文档版本信息。
    *   **主体 (聊天记录):** 一个向上滚动的聊天记录窗口。用户的问题和系统的回答交替显示（建议用不同背景色或对齐方式区分）。系统回答下方必须清晰列出所有可点击的来源引用。
    *   **底部 (输入区):** 一个多行文本输入框，允许用户输入较长的问题。旁边有一个清晰的“发送”按钮（或按 Enter 键发送）。

### 6.2 关键用户流程
*   **首次启动/无项目:** UI 引导用户点击“新建项目”，输入项目号，创建成功后自动选中该项目，并提示可以上传文档。
*   **选择现有项目:** 用户在区域 A 点击项目号，该项目展开，并可进一步选择文档和版本。
*   **上传新文档:** 用户选择项目后，点击“上传新文档”，选择本地 `.docx` 文件。上传后，文件出现在区域 A 该项目下，并开始处理（显示进度）。处理完成后，自动选中该文档的 v1 版本。
*   **上传新版本:** 用户选择一个已存在的基础文档，点击“上传新版本”，选择本地 `.docx` 文件。上传处理后，新版本出现在该文档的版本列表中，并成为最新活动版本。
*   **切换查看版本:** 用户在区域 A 点击某个文档的其他版本号，区域 B 和 C 立即刷新以显示该版本的内容和聊天记录。
*   **进行问答:** 用户在区域 C 输入问题并发送。等待处理后，系统回答和来源引用显示在聊天记录中。
*   **查看来源:** 用户点击回答中的任一来源引用。区域 B 自动滚动到对应内容块，并高亮显示。
*   **软删除版本:** 用户点击某个旧版本旁的删除图标，确认后该版本从默认视图中消失。

### 6.3 设计指南
*   **风格:** 遵循现代 Web 应用设计原则：简洁、干净、专业、注重信息层级。使用 Tailwind CSS 提供的原子类和设计系统来构建一致、美观的界面。
*   **色彩:** 主色调采用中性色（如不同深浅的灰色、白色），确保内容的可读性。使用一种或两种强调色（例如蓝色或绿色）用于按钮、链接、选中状态和高亮效果，保持视觉焦点。
*   **字体:** 选择一款清晰、易读的现代无衬线字体（例如 Inter, Roboto, Source Han Sans/Noto Sans CJK）。确保不同层级文本（标题、正文、注释、标签）有合适的字号、字重和行间距。
*   **布局与间距:** 使用 Tailwind CSS 的间距系统（padding, margin）来创建平衡、呼吸感良好的布局。确保元素对齐，视觉流线清晰。
*   **交互反馈:** 对所有用户操作提供即时、明确的视觉反馈。例如：
    *   按钮悬停和点击状态。
    *   加载状态使用旋转图标或进度条。
    *   表单输入验证提示。
    *   操作成功或失败的消息提示（例如，使用 Toast 通知）。
*   **可访问性 (A11y):** 考虑基本的 Web 可访问性原则，如足够的色彩对比度、键盘导航支持、为图标按钮提供文本标签等（虽然 MVP 可能不深入，但应有此意识）。

## 7. 非功能性需求 (MVP)

*   **性能:**
    *   **响应时间:** UI 交互（如点击、滚动、输入）应感觉流畅无卡顿。基本 API 调用（如获取版本列表、聊天记录）应在 1-2 秒内完成。问答 RAG 流程（检索+LLM调用）力争在 5-10 秒内返回结果（取决于 LLM API 速度和检索复杂度）。
    *   **文档处理时间:** 首次处理大型文档（如 100+ 页）可能需要较长时间（几十秒甚至几分钟，取决于机器性能和文档复杂度），**必须提供清晰的进度反馈 (FR-DU-011)**。
    *   **资源占用:** 本地服务器应合理使用 CPU 和内存，尤其是在空闲时。COM 交互期间的资源占用是暂时的。
*   **安全性:**
    *   **数据本地化:** 核心原则是所有用户文档内容、解析结果、向量数据和元数据均存储在用户本地计算机上，不传输到任何外部公共服务器（LLM API 调用除外）。
    *   **LLM API 调用:** 仅将构建好的 Prompt（包含问题和检索到的文本块）发送给火山方舟 API。不发送整个文档。
    *   **API Key 存储:** API Key 存储在本地 SQLite 中，进行 Base64 编码，降低意外明文暴露风险（非强加密）。
    *   **文件存储:** 上传的文档副本存储在用户本地文件系统的一个指定目录下。需注意该目录的权限（虽然是本地应用，也应避免过于宽松的权限）。
*   **可用性:**
    *   界面设计应直观易懂，主要功能（项目选择、上传、问答、查看来源）易于发现和使用。
    *   关键操作应有撤销或确认步骤（如软删除）。
    *   提供基本的错误提示，帮助用户理解问题所在（如“无法解析此文档”、“API Key 无效或网络错误”）。
*   **可靠性:**
    *   应用程序应能稳定运行，避免无故崩溃。
    *   COM 交互是潜在的不稳定点，必须有健壮的错误处理机制。
    *   数据库操作应使用事务（如果适用）保证数据一致性。
    *   正确处理并发问题（虽然是本地单用户应用，但异步操作如文档处理与用户交互可能存在潜在冲突，需注意）。
*   **部署:**
    *   提供通过 PyInstaller（或类似工具）打包成的单个 `.exe` 可执行文件。
    *   打包过程应包含所有 Python 依赖、前端静态文件、默认配置文件和数据库初始化脚本。
    *   理想情况下，用户下载 `.exe` 文件后，双击即可启动本地服务器并自动（或提示用户手动）在浏览器中打开应用界面 (`http://127.0.0.1:xxxx`)。

## 8. 开发步骤建议 (MVP)

1.  **环境搭建:** 设置 Python 虚拟环境，安装核心依赖 (FastAPI, LlamaIndex, ChromaDB, SentenceTransformers, pywin32, uvicorn, python-multipart, requests, Jinja2 (如果后端渲染模板), python-dotenv (管理配置))。设置前端构建环境 (Node.js, npm/yarn, Tailwind CSS CLI)。
2.  **数据库建模与初始化:** 使用 `sqlite3` 或 ORM (如 SQLAlchemy - 可选，增加复杂度) 定义 SQLite Schema。编写初始化脚本创建表和默认设置。配置 ChromaDB 本地持久化。
3.  **COM 解析封装:** 编写一个 Python 类或模块，封装 `pywin32` 调用 Word 的逻辑。核心功能是输入文件路径，输出提取的段落列表和表格列表（含内容和基本元数据）。实现健壮的错误处理和资源释放。
4.  **LlamaIndex 集成 - 数据处理:**
    *   创建 LlamaIndex `Document` 对象（或自定义 Node）来表示从 COM 获取的块。
    *   实现/配置 `NodeParser` (`TextSplitter`) 进行切分，并将版本 ID 等关键元数据注入每个 Node。
    *   配置 `SentenceTransformerEmbedding` 使用 `bge-base-zh-v1.5`。
    *   编写将 Nodes 存入 ChromaDB (使用 `ChromaVectorStore`) 并关联元数据的逻辑。
5.  **LlamaIndex 集成 - 查询:**
    *   构建 `VectorStoreIndex`。
    *   创建查询引擎 (`index.as_query_engine`)。**关键：** 配置 `VectorStoreQuery` 或使用 `MetadataFilters` 确保查询时能根据传入的 `version_id` 精确过滤 Chunks。
    *   配置 LLM 调用部分，集成火山方舟 API Client。
6.  **FastAPI 后端开发:**
    *   设计并实现 API Endpoints，覆盖项目管理、文档/版本管理（上传、列表、删除）、获取预览 HTML、执行问答、获取聊天记录、设置 API Key 等功能。
    *   集成 SQLite 操作、LlamaIndex 处理流程。
    *   实现文件上传处理逻辑（包括版本检测和存储）。
    *   实现异步任务处理文档（使用 FastAPI 的 `BackgroundTasks` 或 Celery - 可选，增加复杂度）并提供状态查询接口，用于进度反馈。
    *   配置静态文件服务，用于托管编译后的前端文件。
7.  **前端开发 - 基础与布局:** 使用 HTML 和 Tailwind CSS 构建基础的三栏布局和核心 UI 组件（按钮、输入框、列表、树状视图骨架等）。
8.  **前端开发 - 区域 A (项目/文档/版本管理):** 实现与后端 API 的交互，动态加载和展示项目/文档/版本树，处理用户选择、创建、筛选、软删除等操作。
9.  **前端开发 - 区域 B (预览):** 调用 API 获取当前活动版本的 HTML 片段，动态渲染到预览区，实现滚动。
10. **前端开发 - 区域 C (问答):** 实现聊天记录显示（包括来源引用）、问题输入与发送。调用问答 API，处理返回结果并更新聊天界面。
11. **前端开发 - 高亮与导航:** 编写 JavaScript 逻辑，处理来源引用的点击事件，实现预览区的滚动定位和目标元素的动态高亮/取消高亮。
12. **前端开发 - 进度反馈:** 在触发耗时操作（如上传处理）时，调用后端状态接口并显示加载动画或进度条。
13. **整合与测试:** 前后端联调，对核心流程进行完整的功能测试、边界测试和简单性能测试。特别关注版本切换、软删除、多引用、COM 稳定性、长文档处理。
14. **打包:** 配置 PyInstaller 的 `.spec` 文件，包含所有依赖和数据文件（如默认配置、数据库初始化脚本），生成 `.exe` 文件，并在干净的 Windows 环境中测试运行。

## 9. 未来考虑

*(保持 V1.1 的内容)*
*   文档版本差异对比功能。
*   实现图片内容的 OCR 提取与问答。
*   支持同一项目内多文档联合问答。
*   开发独立的跨项目知识库查询模块。
*   数据库与文件存储的集中化部署（公司内部服务器）。
*   研究更高级的文档渲染技术以提升预览保真度。
*   添加用户管理和权限控制。
*   引入更完善的日志记录和监控。
*   支持更多文件格式。

## 10. 附录

### 10.1 默认配置项 (示例)

*   **Embedding Model Name (in Settings):** `bge-base-zh-v1.5`
*   **Chunk Size (in Settings):** `512` (单位：tokens 或 characters，需根据模型和测试确定)
*   **Chunk Overlap (in Settings):** `50` (单位：tokens 或 characters)
*   **LLM API Endpoint (in Settings):** 请参照cursor的 @深度思考 和 @对话(Chat)-文本 API 文档。
*   **LLM API Key (in Settings, Base64 Encoded):** 0d5e7ae6-a55a-40a0-ad0d-4b2f0b4b4e65
*   **LLM Model Name (in Settings):** `doubao-1-5-thinking-pro-250415`
*   **ChromaDB Path (Config/Code):** `./db/chroma_db` (示例本地路径)
*   **SQLite DB Path (Config/Code):** `./db/app_data.db` (示例本地路径)
*   **Document Storage Path (Config/Code):** `./docs_storage` (示例本地路径)

### 10.2 API Key 配置说明
系统需要用户提供有效的火山方舟 API Key 才能进行问答。请在首次使用或通过设置界面配置。API Key 将存储在本地 SQLite 数据库中。

---

**PRD 文档结束。**